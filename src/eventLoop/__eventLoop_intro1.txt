https://javascript.info/event-loop

Browser JavaScript execution flow
Node.js JavaScript execution flow =======> both of them based on an event loop.


Event Loop
- Its an endless loop, 
    where the JavaScript engine waits for tasks, 
    executes them and then sleeps,
    waiting for more tasks.
- general algorithm of the engine:
    While there are tasks:
        execute them, starting with the oldest task.
    Sleep until a task appears, then go to 1.
- (or) simply JS engine does nothing most of the time, it only runs if a script/handler/event activates.


Examples of tasks/scripts/events:
- When an external script <script src="..."> loads, the task is to execute it.
- When a user moves their mouse, the task is to dispatch mousemove event and execute handlers.
- When the time is due for a scheduled setTimeout, the task is to run its callback.

When tasks/scripts/events occur
- Tasks are set – the engine handles them – then waits for more tasks (while sleeping and consuming close to zero CPU).
- It may happen that a task comes while the engine is busy, then it’s enqueued.
- The tasks form a queue, so-called “macrotask queue”           // see image (img_macroTaskQueue)

For instance, while the engine is busy executing a script, 
    a user may move their mouse causing mousemove, 
    and setTimeout may be due and so on, 
    these tasks form a queue, as illustrated in the picture img_macroTaskQueue

Tasks from the queue are processed on “first come – first served” basis. 
When the engine browser is done with the script, it handles mousemove event, then setTimeout handler, and so on.
----------------------------------------------------------------------------------------------------------------

Rendering never happens while the engine executes a task. 
It doesn’t matter if the task takes a long time. 
Changes to the DOM are painted only after the task is complete.
If a task takes too long, the browser can’t do other tasks, such as processing user events. 
So after a time, it raises an alert like “Page Unresponsive”, suggesting killing the task with the whole page.

--------------------------------------------------------------------------------------------------------------
Along with macrotasks, there are microtasks.
Microtasks come solely from our code. 
They are usually created by promises: 
    an execution of .then/catch/finally handler becomes a microtask
Immediately after every macrotask, 
    the engine executes all tasks from microtask queue, 
    prior to running any other macrotasks or rendering or anything else.
All microtasks are completed before any other event handling or rendering or any other macrotask takes place.

--------------------------------------------------------------------------------------------------------------
EventLoop Algorithm

1) Dequeue and run the oldest task from the macrotask queue (e.g. “script”).
2) Execute all microtasks:
    While the microtask queue is not empty:
        Dequeue and run the oldest microtask.
3) Render changes if any.
4) If the macrotask queue is empty, wait till a macrotask appears.
5) Go to step 1.

To schedule a new macrotask:
- Use zero delayed setTimeout(f)
To schedule a new microtask
- Use queueMicrotask(f).
- Also promise handlers go through the microtask queue.


--------------------------------------------------------------------------------------------------------------